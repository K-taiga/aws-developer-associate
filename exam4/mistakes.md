## 質問1
>B社ではクレジットカード処理に対して毎日数百万件のトランザクションを処理しているオンライン詐欺検出ソリューションを構築し、Elastic Beanstalkを利用して展開しています。アプリケーション構成としては、Amazon SQSキューに送信されたファイルをEC2インスタンスが解析処理します。その際に古いデータを読み取るリスクを最小限に抑えるため、ECインスタンスがSQSキューを見つけられないように10秒間の遅延を設定します。

>この要件を満たすSQSキューの設定方法を選択してください。

*A: DelaySecondsパラメーターを設定する*

***
note:

* DelaySecondsパラメーターで遅延キューを設定し、指定した時間が経過してから受信側にメッセージが表示されるようにすることができる
* ロングポーリングではキューを取得する側に待たせる時間を20秒まで設定できるというだけで、遅延させるわけではない
* ショートポーリングは待たないためキューが来てない状態でもコンシューマーがリクエストをする回数が多くなり、コスト効率が悪い

> DelaySecondsパラメーターは遅延キューを設定する際に利用するパラメーターです。遅延キューを使用すると、キューへの新しいメッセージの配信を数秒間遅延させることができます。たとえば、コンシューマーアプリケーションがメッセージの処理に追加の時間を必要とする場合に遅延キューを使用できます。遅延キューを作成した場合、キューに送信したメッセージはいずれも、遅延期間の間コンシューマーに表示されなくなります。キューのデフォルトの (最小) 遅延は 0 秒～最大は 15 分で設定が可能です。   

## 質問7
>D社はチャットボットや音声アプリケーションを展開するAI企業です。現在、音声アプリにはJavaScriptで記述されたAlexaスキルを利用し、Lambda関数を介してスキルを実行しています。あなたはAlexaエンジニアとして、新しい音声アプリを構築しており、音声アクティベーションコマンドをテストしています。しかしながら、一部のIntents（音声スキルの機能）が意図したとおりに実行されず、改善が必要だと判明しました。 Alexaスキルへのリクエストに関する詳細情報を取得することが必要です。

>S3のAlexaLogバケットに保存されたログデータを取得して、詳細情報を確認する方法を選択してください。

*A: Console.logコードをスキルコード内に設定して、CloudWatch統合機能をS3で使用する*

***
note:

* console.logでログ取得の設定、CloudWatch統合機能でS3にログをエクスポートするようにする

> console.logコードをスキルコード内に設定して、ログ取得の設定を行った上で、CloudWatch統合機能をS3で使用することで、ログデータをロググループからAmazon S3バケットにエクスポートして、カスタム処理および分析で使用したり、他のシステムにロードすることができます。

## 質問8
>B社はAWSを利用して様々なWEBアプリケーションを構築しており、最近、SQSメッセージをポーリングするEC２インスタンスとELBとAutoScalingで構成されたWEBアプリケーションを展開しました。しかしながら、このアプリケーションのメッセージ処理数が多く、非同期通信処理が効率に実行されていないようです。WEBアプリケーション側に対して直接のポーリングを利用しないで、受信登録者によるメッセージの並列/非同期処理を可能にする対応が必要です。

>この要件に対応するために最適なサービスの組合せを選択してください。

*A: SNSトSQSを組み合わせて実装する*

***
note:

* SNSからSQSへメッセージを送り並列で非同期に処理を行わせることでWebアプリ側でのポーリングの非効率を解消させる
* SNSは受け取ったメッセージのプロトコルの差を吸収して送信することができ、それをSQSがキューで取得することで並列で処理ができるようにする

>SNSとSQSを使用して、メッセージを複数のサブスクライバーに「プッシュ」するメッセージングシナリオを実装することが可能です。メッセージが複数の受信者に "プッシュ" されるため、更新の定期的な確認やポーリングが必要なくなり、受信登録者によるメッセージの並列/非同期処理を可能にします。 これはファンアウトパターンと呼ばれる構成です。  WEBアプリケーション側に対して直接のポーリングを利用しないで、処理が発行されるようにするという問題となっています。そのためにSNSを起点にしてSQSと連動させることで、WEBアプリケーションからのポーリングが非効率となっていたボトルネックを解消しています。

>次のような実装を実施します。<br>
・通知依頼を送るための、Amazon SNSのトピックを作成する。<br>
・処理ごとにAmazon SQSのキューを作成する。各キューから、SNSのトピックをサブスクライブしておく。<br>
・処理ごとにプログラムを分割し、それぞれSQS のキューをポーリングするようにして、プロセスを起動しておく。<br>
・処理が開始されたときに、初めのプロセスがSNSのトピックへ通知を依頼する。
・SNSはSQSのキューに対し、メッセージを送信する。<br>
・キューをポーリングしていたプロセスがメッセージを取得し、処理を並列に実行する。

## 質問9
>A社はAWSを利用して様々なWEBアプリケーションを構築しており、開発チームは主に.NETを利用しています。WEBアプリケーションのリリースプロセスを自動化するため、AWS Elastic Beanstalkを利用することも求められています。あなたはエンジニアとして、アプリケーションの複数のバージョンがAWS Elastic Beanstalkで実行できるように、デプロイプロセスの設定を担当しています。デプロイの分け方としては、 1つのバージョンは本番環境に使用され、もう1つのバージョンは負荷テストに使用されます。 

>このリリースプロセスの設定方法を選択してください。

*A: ElasticBeansTalkに本番環境の設定と同じ構成をした環境設定を追加する*

***
note:

* 負荷テストに使用できるように、アプリケーションの複数バージョンをAWS Elastic Beanstalkによって展開することができるようにする必要がある
* それは本番環境に近い設定を持つ負荷環境を追加して定義する
* ワーカー環境は負荷が重いものをやらせるための環境のため、そこで処理したら負荷テストにならない

## 質問13:不正解
>金融機関のC社ではフィンテック企業として、様々な金融サービスを展開しています。現在あなたが開発しているオンライン決済プラットフォームは、Auto ScalingグループとELBを設定したEC2インスタンスにホストされています。 開発者は、金融規制要件に従って、VPCのネットワークインターフェイスを行き来するIPトラフィックに関する情報を取得する必要があります。

>この要件に対応するための方法を選択してください。

*A: VPCでフローログを作成して、VPCのネットワークインターフェイスを行き来するIPトラフィックに関する情報をキャプチャする*

***
note:

* VPC フローログは、VPC のネットワークインターフェイスとの間で行き来する IP トラフィックに関する情報をキャプチャする機能
* フローログデータは Amazon CloudWatch Logs と Amazon S3 に発行できる

## 質問14:不正解
>A社はAWSのサーバレスアーキテクチャを社内で新規採用することになり、オンプレミスデータセンターでホストされるWEBアプリケーションをLambdaとAPI Gatewayを使用してAWSに移行したいと考えています。あなたはエンジニアとして、サーバーレスアーキテクチャの自動展開を使用して、社内リソースをクラウドに移行しているところです。そのため、 AWS Lambda関数を実装するCloudFormationテンプレートをYAMLで作成しました。 

>AWS Lambda関数とAWS CloudFormationテンプレートをAWSにアップロードするAWS CLIコマンドを選択してください。（2つ選択してください。）

*A: aws cloudformation deploy,aws cloudformation packageコマンドを利用する*

***
note:

* aws cloudformation packageでローカルで開発しているものをパッケージ化する
* Lambda関数のソースコードやAWS API Gateway REST APIのSwaggerファイルなどローカルで開発したものをS3バケットにアップロード
* それをローカルからS3にアップしたものに参照を切り替える
* 上記でテンプレートのアーティファクトをパッケージ化した後、 aws cloudformation deployでdeployコマンドを実行して、返されたテンプレートをデプロイする

## 質問15:不正解
>B社ではAmazon ECSを利用してWEBアプリケーションを構築しています。このアプリケーション向けに、単一のdockerコンテナー環境がElastic Beanstalkによってホストされています。あなたは開発者として、ECSクラスターのタスク定義を設定して、タスクを実行するのに十分なリソースがあるインスタンスでタスクがスケジュールされる設定を行っています。暗黙的または明示的に指定した制約に従うことが必要です。

>この要件に対応して、適切に実装するための方法を選択してください。

*A: タスク配置戦略でrandomを設定する*

***
note:

* デフォルトでは、タスクはRunTaskでランダムに配置されるか、CreateServiceでアベイラビリティーゾーンにspreadされる

>■binpack <br>使用可能な最小量のCPUまたはメモリに基づいてタスクを配置します。これにより、使用中のインスタンスの数が最小限に抑えられます。 <br>
■random <br>タスクをランダムに配置します。<br>
■spread <br>指定された値に基づいてタスクを均等に配置します。有効な値は instanceId (または同じ効果を持つ host)、または attribute:ecs.availability-zone などのコンテナインスタンスに適用される任意のプラットフォームまたはカスタム属性です。サービスタスクはそのサービスからのタスクに基づいて分散されます。スタンドアロンタスクは、同じタスクグループからのタスクに基づいて分散されます。

* binpackはできるだけ少ないインスタンスにタスクを配置し、リソース使用率を最適化する
* spreadは、クラスター全体にタスクを均等に配置して可用性を最大化する　デフォルトでは、ECSはecs.availability-zone属性を持つスプレッドを使用してタスクを配置する
* randomはインスタンスにタスクをランダムに配置しますが、暗黙的または明示的に指定した他の制約を尊重することができる　つまりランダムだけがこちら側で作ったルールでタスク配置ができる

## 質問16:不正解
>B社ではCloudFormationを利用した環境構築の自動化を行っています。あなたはエンジニアとして、AWSアカウント内のEC2インスタンスで実行されているCMSアプリケーションをデプロイするCloudFormationテンプレートを作成しているところです。 複数のリージョンにアプリケーションをデプロイするため、設定するべきAMIに対するMappingの設定が必要です。

>この要件を満たすことができるFindInMap関数の設定方法を選択してください。

*A: Fn::FindInMap:[MapName,TopLevelKey,SecondLevelKey]で設定する*

***
note:

* 組み込み関数 Fn::FindInMap は、Mappings セクションで宣言された 2 つのレベルのマッピングのキーに対応する値を返す。Fn::FindInMap: [ MapName, TopLevelKey, SecondLevelKey ]と定義する必要あり

## 質問17:不正解
>ある会社では先月CloudFormationを使用して、API GatewayからLambdaを呼び出して、DynamoDBへとデータを記録・取得するサーバーレスアプリケーションを展開しました。このアプリケーションのバージョン更新が発生し、AWS SAMを使用してデプロイする予定です。 トラフィックは可能な限り最短時間にしつつも、以前のバージョンから新しいバージョンに徐々に移行する必要があります。

>これらの要件を満たすために最も適した展開設定を選択してください。

*A: CodeDeployDefault.LambdaCanary10Percent5Minutesを設定する*

***
note:

* デプロイ中にトラフィックをシフトするには以下の3パターンがある
* Canary10Percent5Minutesは最初の増分でトラフィックの10％をシフトします。残りの90％は5分後に展開されるという意味
* Linearは最後まで等間隔でシフトされる
* All-at-onceは一気にシフトされる

>■Canary <br>トラフィックは2つの増分でシフトされます。事前定義されたカナリアオプションから選択して、最初の増分で更新されたLambda関数バージョンにシフトされるトラフィックの割合と、残りのトラフィックが2番目の増分でシフトされるまでの間隔を分単位で指定できます。<br>
■Linear <br>トラフィックは、増分ごとに等しい分数で等間隔にシフトされます。各増分でシフトされるトラフィックの割合と各増分間の分数を指定する定義済みの線形オプションから選択できます。 <br>
■All-at-once<br> すべてのトラフィックは、元のLambda関数から更新されたLambda関数バージョンに一度にシフトされます。  さらにAWS Lambdaデプロイで利用可能な事前定義された設定を利用することができます。

## 質問21:不正解
>開発者はAWS上でサーバレスアプリケーションを構築しました。このアプリケーションのバグ修正やパフォーマンス最適化のためにAWS X-Rayを使用して、実行中のサーバレスアプリケーションをトレースする必要があります。 様々な外部アプリケーションがこのアプリケーションを呼び出すため、そのリクエスト処理もX-Rayでトレースする必要があります。

>この要件を満たす最適なX-Ray設定を選択してください。（2つ選択してください。）

*A: PutTraceSegments APIを使用して、セグメントドキュメントをX-Rayに直接送信する*<br>
*セグメントとサブセグメントをX-Rayデーモンに送信し、それらをバッファリングしてバッチでX-Ray APIにアップロードする*

***
note:

* PutTraceSegments APIでセグメントドキュメントをX-Rayに直接送信するか、セグメントとサブセグメントをX-Rayデーモンに送信し、それらをバッファリングしてバッチでX-Ray APIにアップロードするという方法がある

> トレースデータは、セグメントドキュメントの形式で X-Ray に送信できます。セグメントドキュメントはアプリケーションがリクエストのサービスで行う作業に関する情報を含む JSON 形式の文字列です。セグメント内で行われる作業、またはサブセグメントのダウンストリームサービスおよびリソースを使用する作業に関するデータはアプリケーションに記録できます。

>セグメントドキュメントは最大64 kBで、サブセグメントを含むセグメント全体、リクエストが進行中であることを示すセグメントのフラグメント、または個別に送信される単一のサブセグメントを含むことができます。 PutTraceSegments APIを使用して、セグメントドキュメントをX-Rayに直接送信できます。

>別の方法として、セグメントドキュメントをX-Ray APIに送信する代わりに、セグメントとサブセグメントをX-Rayデーモンに送信し、それらをバッファリングしてバッチでX-Ray APIにアップロードします。 X-Ray SDKは、AWSを直接呼び出すことを避けるために、セグメントドキュメントをデーモンに送信します。

## 質問23:不正解
>現在、A社ではAmazon ECSを利用したDockerによるアプリケーション開発を実施しています。 あなたはエンジニアとして、AWS CLIを使用してプロセスを自動化設定を行っています。この設定では5個のタスク定義されたインスタンスがデフォルトのクラスターで実行されることが必要です。

>この要件を満たす最適なコマンド操作を選択してください。

*A: aws ecs create-service --service-name ecs-simple-service --task-definition ecs-demo --desired-count5*

***
note:

* 展開する場所はecs-simple-serviceというデフォルトのリージョン --service-name ecs-simple-serviceというサービス名で--task-definitioはecs-demoタスク定義を使用し、desired-count 5によりタスクに対する5個のインスタンス化を作成する

## 質問25:不正解
>現在、A社ではAWSにホストした注文管理アプリケーションを開発しています。開発完了後、コードをAWS CodeCommitにコミットし、サーバーにデプロイする前にAWS CodeBuildでプロジェクトを構築します。しかしながら、ビルドに時間がかかりすぎており、エラーが発生してしまいました。

>ビルドが長く実行されないようにするため、AWS CLIを利用した設定変更方法を選択してください。

*A: queuedTimeoutInMinutesOverride:を設定する*

***
note:

>CodeBuildタイムアウトを有効することにより、構成されたタイムアウトの期限が切れると、ビルドプロセスが自動的に終了します。 デフォルトは60分です。AWS CLIではqueuedTimeoutInMinutesOverride: を設定します。これは、ビルドをキューに入れてからタイムアウトするまでの時間 (分) を指定するオプションで、その最小値は 5 分、最大値は 480 分 (8 時間) でタイムアウト時間を設定することが可能です。 

## 質問26:不正解
>B社ではIoTアプリケーションの開発を実施しています。リアルタイムデータ処理を進めるために10個のシャードを含むAmazon Kinesis Data Streamsがあり、GetRecords によるデータ送信処理のスループット使用率は毎秒10 MBを大きく下回っています。しかしながら、1秒あたり3 MBのデータを送信しても、ProvisionedThroughputExceededExceptionエラーが頻繁に発生してしまいます。

>この問題の根本原因として可能性が高い要因を選択してください。

*A: 選択したパーティションキーが十分に配布されていない*

***
note:

* 書き込みは1個のシャードにつき1MB/seconds,1000records/secondまでなのでこれを超えて書き込みをした場合にはProvisionedThroughputExceededExceptionエラーが発生し他のシャードも使ってしまい読み込みとかができなくなる
* 読み取りはGetRecordsで最大10MB返せるが、書き込みでシャードのパーティションキーが十分に配布されておらず処理が分散できていないため読み込みでエラーが発生している

>Amazon Kinesis Data Streamsではシャードあたりの書き込み制限は以下があります。<br>
・1000 records/second<br>
・1 MB/second<br>
これを超えたデータ量が発生した場合に、ProvisionedThroughputExceededExceptionエラーとなります。選択したパーティションキーが十分に配布されていないため、少数の特定のシャードにおけるデータが歪んでおり、シャードのクラスター全体を活用していません。そのため、データ量が制限を超えてしまいProvisionedThroughputExceededExceptionエラーが発生します。<br>
コンシューマーアプリケーションが 1 つのみである場合、通常、PUT レートの少なくとも 2 倍高速に読み取りを実行できます。これは、書き込みについては最大 1 秒あたり 1,000 レコード、データの最大書き込み合計レートは 1 秒あたり 1 MB (パーティションキーを含む) まで書き込むことができるためです。開いている各シャードは 読み取りは最大 1 秒あたり 5 件のトランザクション、データ読み取りの最大合計レートは 1 秒あたり 2 MB をサポートできます。各読み取り (GetRecords) は、レコードのバッチを取得します。GetRecords によって返されるデータのサイズは、シャードの使用状況によって異なります。GetRecords が返すことができるデータの最大サイズは10 MB です。呼び出しがその制限を返す場合、次の 5 秒以内に行われるそれ以降の呼び出しは ProvisionedThroughputExceededException が発生します。 

## 質問27:不正解
>B社ではEC2にAutoScalingを設定した構成でWEBアプリケーションの開発を実施しています。開発担当者にIAMユーザーを設定し、AWS CLIを呼び出すシェルスクリプトを使用して開発環境で作業しています。 EC2インスタンスに開発環境へのアクセスするためのIAMロールが付与されています。このEC2インスタンスに新しいIAMロールを付与しました。

>EC２インスタンスのロールを切り替える最も簡単な方法を選択してください。

*A: AWS CLI設定ファイルでロールの新しいプロファイルを作成し、CLIコマンドを実行するたびに、新しいプロファイル名と共に--profileパラメーターを追加する*

***
note:

* EC2に割り当てられているIAMロールの権限が変わったため、それをEC2に反映させたい
* インスタンスプロファイルにはIAMロールが含まれており、インスタンスで実行されるアプリケーションにロールの一時的な認証情報を提供している
* 一度に1つのロールのみをEC2インスタンスに割り当てることができ、インスタンス上のすべてのアプリケーションは同じロールと権限を共有する

>ロールの資格情報は一時的なものであり、自動的にローテーションされるため、資格情報を管理する必要はなく、長期的なセキュリティリスクを心配する必要もありません。さらに、複数のインスタンスに単一のロールを使用する場合、その1つのロールに変更を加えると、変更がすべてのインスタンスに自動的に伝播されます。現在のアクセス許可で特定のIAMロールを引き受けることができる場合、AWS CLI設定ファイルの「プロファイル」でそのロールを特定できます。そのコマンドは、元のIDではなく、指定されたIAMロールのアクセス許可で実行されます。AWS CLIコマンドでそのプロファイルを指定する場合、新しいロールを使用することになります。 

## 質問30:不正解
>A社では仮想通貨取引アプリケーションを開発・運用しています。DNS名がインスタンスのIPアドレスを指しているEC2インスタンスでパブリックDNSサービスを実行しています。 DNSサービスをアップグレードする際に、ダウンタイムを最小限とする方式が求められています。 

>ダウンタイムを最小限とするDNSをアップグレードする方法を選択してください。

*A: ElasticIPを追加する*

***
note:

* Elastic IPを利用して新しいインスタンスを別途用意しておいて、切替時はAmazonのコンソール上でIPアドレスによってDNSを切り替えるだけで、ダウンタイムの発生を抑えて容易に切り替えることが可能

## 質問32:不正解
>あなたはAWS専門のエンジニアとして、様々なニュースデータを収集してSNSで閲覧できるモバイルアプリを構築しています。ユーザーは、Twitter、Facebook、GoogleなどのソーシャルIDプロバイダーを使用して認証してサイトにログインできます。 追加機能として、ゲストユーザーがモバイルアプリの特定のセクションにアクセスできるようにする必要があります。

>この要件を達成するには、どのような設定が必要ですか？

*A: AmazonCognitoでIDプールを作成し、認証されていないIDヘのアクセスを有効にする*

***
note:

* ゲストユーザーという権限が制限された一時的な AWS 認証情報を取得して、他の AWS サービスにアクセスさせる機能はIDプールで行う
* そしてそのIDプールを使ってユーザープールから、Amazon、Facebook、Google、SAML IDプロバイダーを含むフェデレーションIDプロバイダー、および認証されていないIDを介したユーザー認証を行うようにする
* Amazon CognitoでIDプールを作成し、認証されていないIDへのアクセスを有効にすることが、正しい実装方法

> ユーザプールは Amazon Cognito のユーザディレクトリです。ユーザープールを使用すると、ユーザーは Amazon Cognito を通じてウェブまたはモバイルアプリにログインできます。また、ユーザーは Google、Facebook、Amazon、Apple などのソーシャル ID プロバイダー、および SAML ベースの ID プロバイダー経由でユーザープールにサインインすることもできます。 

## 質問33:不正解
>あなたはAWSアカウントのアクセス管理を担当している管理担当者です。すべての開発者は、AWS CLIを使用してコマンドを実行すると、エンコードされた認証失敗メッセージが表示される障害が発生しています。認証が上手くデコードされるように設定変更が必要です。

>メッセージをデコードするのに役立つ実装方法を選択してください。

*A: AWS STS decode-authorization-messageを使用してデコード処理を実装する。*

***
note:

* AWS STS decode-authorization-messageを使用して、AWSリクエストに応答して返されたエンコードされたメッセージからリクエストの承認ステータスに関する追加情報をデコードする
* ダメならClient.UnauthorizedOperation応答（HTTP 403応答）を返す

## 質問35:不正解
>B社はAWSでサーバーレスアプリケーションを構築しています。 アプリケーションは、AWS Lambda、API Gateway、およびDynamoDBによる単一のスタックで構成されてます。Lambda関数はDynamoDBのデータを1日に４～５回更新します。 クライアントは、Amazon API Gatewayによって公開されたAPIを介してDynamoDBから直接データを取得します。 APIキャッシュは有効になっていますが、送信されたすべてのAPIリクエストに対してDynamoDBから最新のデータを取得することが求められています。そのため、APIリクエストを送信するときに、許可されたクライアントのみがAPI Gatewayキャッシュエントリを無効にする必要があります。

>この要件を達成するには、どのような設定が必要ですか？（3つ選択してください。）

*A: API Gatewayのコンソールで[Require authorization(認証が必要)]にチェックを入れる*<br>
*クライアントにCache-コントロール:max-age=0ヘッダーを設定する*<br>
*キャッシュのデフォルトのTTL値を0に設定する*

***
note:

* Require authorizationで承認済みのクライアント全てはキャッシュを無効にすることができる
* クライアントのヘッダーにache-Control: max-age=0 ヘッダーを追加して 既存のキャッシュを無効にして新たにAPIから取得する
* そしてキャッシュの有効期限を0にしてキャッシュを無効化させる

> [Require authorization (認証が必要)] チェックボックスをオンにした場合)、すべてのクライアントが API キャッシュを無効にできます。クライアントのAPI キャッシュを無効にする場合、API のレイテンシーが非常に大きくなる可能性があります。ポリシーが適用され、キャッシュが有効になり、認証が必要な場合、API Gateway コンソールの [未認証リクエストの処理] からオプションを選択して、未認証リクエストの処理方法を制御できます。 

>API のクライアントは既存のキャッシュエントリを無効化し、個別のリクエストに対して統合エンドポイントからそのエントリを再ロードできます。クライアントは、Cache-Control: max-age=0 ヘッダーを含むリクエストを送信する必要があります。クライアントは、クライアントが許可されている場合、キャッシュの代わりに統合エンドポイントから直接レスポンスを受け取ります。これは既存のキャッシュエントリを、統合エンドポイントから取得される新しいレスポンスで置き換えます。したがって、APIリクエストを送信するときに、承認されたクライアントのみがAPI Gatewayキャッシュエントリを無効にできるようにする

>Amazon API Gateway で API キャッシュを有効にして、エンドポイントのレスポンスがキャッシュされるように設定できます。キャッシュを有効にすると、エンドポイントへの呼び出しの数を減らすことができ、また、API へのリクエストのレイテンシーを短くすることもできます。ステージに対してキャッシュを有効にすると、API Gateway は、秒単位で指定した有効期限 (TTL) が切れるまで、エンドポイントからのレスポンスをキャッシュします。その後、API Gateway は、エンドポイントへのリクエストを行う代わりに、キャッシュからのエンドポイントレスポンスを調べてリクエストに応答します。API キャッシュのデフォルトの TTL 値は 300 秒です。最大の TTL 値は 3600 秒です。TTL=0 は、キャッシュが無効なことを意味します。   
